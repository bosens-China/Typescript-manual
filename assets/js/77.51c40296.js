(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{754:function(t,o,e){"use strict";e.r(o);var a=e(13),n=Object(a.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"用现有类型创建新类型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#用现有类型创建新类型"}},[t._v("#")]),t._v(" 用现有类型创建新类型")]),t._v(" "),o("p",[t._v("TypeScript 的类型系统非常强大，因为它允许用"),o("em",[t._v("其他类型")]),t._v("表达类型。")]),t._v(" "),o("p",[t._v("这个想法最简单的形式就是泛型。此外，我们还有多种"),o("em",[t._v("类型操作符")]),t._v("可以使用。我们也可以用我们已有的"),o("em",[t._v("值")]),t._v("表达类型。")]),t._v(" "),o("p",[t._v("通过组合不同的类型操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。在本部分中，我们将介绍如何用现有的类型或值表达新的类型。")]),t._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/generics.html"}},[t._v("泛型")]),t._v(" —— 带有参数的类型")],1),t._v(" "),o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/keyof-type-operator.html"}},[t._v("Keyof 类型操作符")]),t._v(" —— 使用  "),o("code",[t._v("keyof")]),t._v("  操作符创建新的类型")],1),t._v(" "),o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/typeof-type-operator.html"}},[t._v("Typeof 类型操作符")]),t._v(" —— 使用  "),o("code",[t._v("typeof")]),t._v("  操作符创建新的类型")],1),t._v(" "),o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/indexed-access-types.html"}},[t._v("索引访问类型")]),t._v(" —— 使用  "),o("code",[t._v("Type['a']")]),t._v("  语法访问类型的子集")],1),t._v(" "),o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/conditional-types.html"}},[t._v("条件类型")]),t._v(" —— 类型系统中类似于 if 语句的类型")],1),t._v(" "),o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/mapped-types.html"}},[t._v("映射类型")]),t._v(" —— 通过映射现有类型的每个属性创建类型")],1),t._v(" "),o("li",[o("RouterLink",{attrs:{to:"/download/zh/handbook-v2/type-manipulation/template-literal-types.html"}},[t._v("模板字面量类型")]),t._v(" —— 通过模板字面量字符串改变属性的映射类型")],1)])])}),[],!1,null,null,null);o.default=n.exports}}]);